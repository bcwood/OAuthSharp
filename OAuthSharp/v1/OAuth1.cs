using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace OAuthSharp
{
	/// <summary>
	/// Utility class used for implementing OAuth 1.0 spec, as defined by RFC 5849.
	/// Ref: http://tools.ietf.org/html/rfc5849
	/// </summary>
	public static class OAuth1
	{
		/// <summary>
		/// Generates an OAuth-compliant nonce.
		/// (ref: http://tools.ietf.org/html/rfc5849#section-3.3)
		/// 
		/// A nonce is a random string, uniquely generated by the client to allow the server to verify that a request has 
		/// never been made before and helps prevent replay attacks. The nonce value MUST be unique across all requests with 
		/// the same timestamp, client credentials, and token combinations.
		/// </summary>
		/// <returns>OAuth-compliant nonce</returns>
		public static string GenerateNonce()
		{
			return Guid.NewGuid().ToString().Replace("-", "").Substring(0, 10);
		}

		/// <summary>
		/// Generates an OAuth-compliant timestamp.
		/// (ref: http://tools.ietf.org/html/rfc5849#section-3.3)
		/// 
		/// The timestamp value MUST be a positive integer. Unless otherwise specified by the server's documentation, 
		/// the timestamp is expressed in the number of seconds since January 1, 1970 00:00:00 GMT.
		/// </summary>
		/// <returns>OAuth-compliant timestamp</returns>
		public static long GenerateTimestamp()
		{
			DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0, 0);
			TimeSpan ts = DateTime.UtcNow - epoch;
			return Convert.ToInt64(ts.TotalSeconds);
		}

		/// <summary>
		/// Signs the request using the appropriate signature method.
		/// (ref: http://tools.ietf.org/html/rfc5849#section-3.4)
		/// </summary>
		public static string GetSignature(string url, Dictionary<string, string> parameters, string signatureMethod, string hashKey)
		{
			switch (signatureMethod)
			{
				case OAuth1Constants.SIGNATURE_METHOD_PLAINTEXT:
					return hashKey;

				case OAuth1Constants.SIGNATURE_METHOD_HMAC_SHA1:
					string signatureBase = OAuth1.GetSignatureBase(url, parameters);
					byte[] signatureBytes = Encoding.ASCII.GetBytes(signatureBase);

					var sha1 = new HMACSHA1 { Key = Encoding.ASCII.GetBytes(hashKey) };
					byte[] hashBytes = sha1.ComputeHash(signatureBytes);

					return Convert.ToBase64String(hashBytes);

				default:
					throw new NotSupportedException("Unsupported signature method: " + signatureMethod);
			}
		}

		/// <summary>
		/// Formats the list of request parameters into "signature base" string. 
		/// (ref: http://tools.ietf.org/html/rfc5849#section-3.4.1)
		/// </summary>
		private static string GetSignatureBase(string url, Dictionary<string, string> parameters)
		{
			// start with the method and the encoded URI
			var sb = new StringBuilder();
			sb.AppendFormat("POST&{0}&", OAuth1.UrlEncode(OAuth1.NormalizeUrl(url)));

			Dictionary<string, string> queryParams = OAuth1.ExtractQueryParameters(url);

			foreach (var param in parameters)
			{
				// Exclude all oauth params that are secret or
				// signatures; any secrets should be kept to ourselves,
				// and any existing signature will be invalid.
				if (!String.IsNullOrEmpty(param.Value) &&
					!param.Key.EndsWith("_secret") &&
					!param.Key.EndsWith("signature"))
					queryParams.Add("oauth_" + param.Key, param.Value);
			}

			// concat params
			var paramBuilder = new StringBuilder();
			foreach (var item in queryParams.OrderBy(p => p.Key))
			{
				// even "empty" params need to be encoded this way.
				paramBuilder.AppendFormat("{0}={1}&", item.Key, item.Value);
			}

			// append the UrlEncoded version of that string to the sigbase
			sb.Append(OAuth1.UrlEncode(paramBuilder.ToString().TrimEnd('&')));

			return sb.ToString();
		}

		/// <summary>
		/// Normalizes a URL for use in the OAuth "signature base" string.
		/// (ref: http://tools.ietf.org/html/rfc5849#section-3.4.1.2)
		/// </summary>
		public static string NormalizeUrl(string url)
		{
			var uri = new Uri(url);
			var normalizedUrl = string.Format("{0}://{1}", uri.Scheme, uri.Host);

			// append non-standard port
			if (!((uri.Scheme == "http" && uri.Port == 80) || (uri.Scheme == "https" && uri.Port == 443)))
				normalizedUrl += ":" + uri.Port;

			normalizedUrl += uri.AbsolutePath;

			return normalizedUrl;
		}

		/// <summary>
		/// Generates the OAuth-compliant authorization header.
		/// (ref: http://tools.ietf.org/html/rfc5849#section-3.5.1)
		/// </summary>
		public static string GetAuthorizationHeader(Dictionary<string, string> parameters, string realm = null)
		{
			string encodedParams = OAuth1.EncodeParameters(parameters);

			return (string.IsNullOrEmpty(realm))
				       ? "OAuth " + encodedParams
				       : string.Format("OAuth realm=\"{0}\", {1}", realm, encodedParams);
		}

		/// <summary>
		/// OAuth-compliant URL encoder.
		/// (ref: http://tools.ietf.org/html/rfc5849#section-3.6)
		/// 
		/// The default .NET encoder outputs the percent encoding in lower case.
		/// RFC 5849 requires that the characters be upper case:
		/// 
		/// 1. Characters in the unreserved character set as defined by RFC 3986, Section 2.3 
		///    (ALPHA, DIGIT, "-", ".", "_", "~") MUST NOT be encoded.
		/// 2. All other characters MUST be encoded.
		/// 3. The two hexadecimal characters used to represent encoded characters MUST be uppercase.
		/// </summary>
		/// <returns>OAuth-compliant URL encoded string</returns>
		public static string UrlEncode(string value)
		{
			const string UNRESERVED_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_.~";

			var encoded = new StringBuilder();

			foreach (char c in value)
			{
				if (UNRESERVED_CHARS.IndexOf(c) >= 0)
					encoded.Append(c);
				else
					encoded.Append('%' + String.Format("{0:X2}", (int) c));
			}

			return encoded.ToString();
		}

		/// <summary>
		/// Encodes the list of request parameters suitable for use in the Authorization header of the request.
		/// </summary>
		private static string EncodeParameters(Dictionary<string, string> parameters)
		{
			var sb = new StringBuilder();

			foreach (var item in parameters.OrderBy(x => x.Key))
			{
				if (!string.IsNullOrEmpty(item.Value) && !item.Key.EndsWith("secret"))
					sb.AppendFormat("oauth_{0}=\"{1}\", ",
					                item.Key,
					                UrlEncode(item.Value));
			}

			return sb.ToString().TrimEnd(' ').TrimEnd(',');
		}

		/// <summary>
		/// Extracts all query string parameters from a URL that are not related to OAuth (not beginning with "oauth_").
		/// </summary>
		/// <returns>Parameter Dictionary</returns>
		private static Dictionary<string, string> ExtractQueryParameters(string url)
		{
			var uri = new Uri(url);
			string queryString = uri.Query;

			if (queryString.StartsWith("?"))
				queryString = queryString.Remove(0, 1);

			var parameters = new Dictionary<string, string>();

			if (String.IsNullOrEmpty(queryString))
				return parameters;

			foreach (string keyValuePair in queryString.Split('&'))
			{
				if (!String.IsNullOrEmpty(keyValuePair) && !keyValuePair.StartsWith("oauth_"))
				{
					if (keyValuePair.IndexOf('=') >= 0)
					{
						string[] parts = keyValuePair.Split('=');
						parameters.Add(parts[0], parts[1]);
					}
					else
						parameters.Add(keyValuePair, String.Empty);
				}
			}

			return parameters;
		}
	}
}
